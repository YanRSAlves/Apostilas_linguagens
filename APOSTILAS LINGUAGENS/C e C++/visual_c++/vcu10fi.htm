<HTML>

<HEAD>

<TITLE>Visual C++ Unleashed vcu10fi.htm</TITLE>

<LINK REL="ToC" HREF="index.htm">

<LINK REL="Next" HREF="vcu11fi.htm">

<LINK REL="Previous" HREF="vcu09fi.htm"></HEAD>

<BODY TEXT="#000000" LINK="#0000FF" VLINK="#FF0000" bgcolor=white>

<P><A HREF="vcu09fi.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="index.htm"><IMG SRC="blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="vcu11fi.htm"><IMG SRC="blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>

</P><UL>

<LI>

<A HREF="#I1">10 &#151; Resource Files</A></LI>

<UL>

<UL>

<LI>

<A HREF="#I2">Resource File Components</A></LI>

<UL>

<LI>

<A HREF="#I4">Resource File Preprocessing</A></LI>

<LI>

<A HREF="#I5">Single-Line Statements</A></LI>

<LI>

<A HREF="#I6">Multiline Resource Statements</A></LI>

<UL>

<LI>

<A HREF="#I7">Accelerators</A></LI>

<LI>

<A HREF="#I8">Dialogs</A></LI>

<LI>

<A HREF="#I9">Menus</A></LI>

<LI>

<A HREF="#I10">String Tables</A></LI>

<LI>

<A HREF="#I11">Toolbars</A></LI>

<LI>

<A HREF="#I12">Version Information</A></LI></UL>

<LI>

<A HREF="#I13">User-Defined and Raw Data Resources</A></LI></UL>

<LI>

<A HREF="#I14">Compiling and Using Resource Scripts</A></LI>

<UL>

<LI>

<A HREF="#I15">Running the Resource Compiler</A></LI>

<LI>

<A HREF="#I16">Running the Linker</A></LI>

<LI>

<A HREF="#I17">Resource DLLs</A></LI></UL>

<LI>

<A HREF="#I18">Summary</A></LI></UL></UL></UL>



<H1 ALIGN="CENTER">

<CENTER><A ID="I1" NAME="I1">

<BR>

<FONT SIZE=5><B>10 &#151; Resource Files</B>

<BR></FONT></A></CENTER></H1>

<P>Resource files represent one of the most prominent features of Windows programming. It is through resource files that most applications define the visible elements of their user interface: menus, dialogs, text strings, bitmaps, and other types of resources.

<BR></P>

<P>Resource files are created in a form readable by humans and compiled with the <I>Resource Compiler</I>. The compiled result is usually linked with the rest of the application to form a single binary image that contains executable code and resource information.

<BR></P>

<P>Strictly speaking, use of resource files is not mandatory. However, it would be foolish to write needlessly complex code to implement an application's user-interface elements when resource files provide a convenient way to do the same. Furthermore, the use of resource files makes it much easier to replace language-dependent user-interface elements when working on an application that will be used in multiple language environments.

<BR></P>

<P>In the &quot;good old days&quot; programmers used a text editor to edit a resource file. These days, hand-editing of resource files is rare. Instead, graphical resource editors are used, such as the integrated resource editor that is part of the Developer Studio. Nevertheless, the ability to make sense of resource file contents, the ability to hand-edit resource files when necessary, can still prove to be a useful skill. The syntax and the structure of resource files are simple, and understanding what is &quot;under the hood&quot; helps put the features of sophisticated editors in perspective.

<BR></P>

<P>This chapter presents a review of the use of resource files and the resource compiler.

<BR></P>

<HR ALIGN=CENTER>

<NOTE>

<IMG SRC="note.gif" WIDTH = 35 HEIGHT = 35><B>NOTE:</B> Often, the term <I>resource file</I> is used to apply to files generated by the resource compiler; in other words, files with the .res extensions. However, in this text I use the term exclusively to refer to files containing resource scripts; that is, files with the .rc extension.

<BR></NOTE>

<HR ALIGN=CENTER>

<H3 ALIGN="CENTER">

<CENTER><A ID="I2" NAME="I2">

<FONT SIZE=4><B>Resource File Components</B>

<BR></FONT></A></CENTER></H3>

<P>A resource file, or resource script may contain any number of resource script statements and preprocessor directives. For example, consider the sample resource file shown in Listing 10.1.

<BR></P>

<UL>

<LH><B>Listing 10.1: Resource script example.</B></LH></UL>

<PRE>#include &lt;windows.h&gt;

DlgBox DIALOG 20, 20, 90, 64

STYLE DS_MODALFRAME | WS_CAPTION | WS_SYSMENU

CAPTION &quot;Sample Dialog&quot;

BEGIN

    DEFPUSHBUTTON &quot;Sample Button&quot;, IDOK, 19, 44, 52, 14, WS_GROUP

    CTEXT &quot;Sample Message&quot;, -1, 0, 8, 90, 8

END</PRE>

<P>This simple script defines a dialog with a button and a static text field (Figure 10.1). The dialog will be referred to by name (DlgBox) from the application using this resource. Although it is not obvious at first sight, some constants (for example, IDOK, DS_MODALFRAME or WS_GROUP) are defined in the file windows.h and not part of the resource script language. The C/C++ style #include directive is used to specify files that contain macro definitions.

<BR></P>

<P>

<BR><B><A HREF="10vcu01.gif">Figure 10.1. Sample dialog box.</A></B>

<BR></P>

<P><A ID="I3" NAME="I3"></A>Generally, a resource file statement consists of an identifier that can either be a text string (DlgBox above) or a numeric value, followed by the statement itself. The statement can be single line (in which case, the statement is followed by one or more parameters) or multiline (in which case the statement is followed by a block of script instructions).

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I4" NAME="I4">

<FONT SIZE=3><B>Resource File Preprocessing</B>

<BR></FONT></A></CENTER></H4>

<P>Preprocessor syntax and semantics are similar to the syntax and semantics of the C/C++ preprocessor. The resource compiler preprocessor, or RC preprocessor for short, understands the following directives:

<BR></P>

<UL>

<LI>Macro definitions: #define and #undef

<BR>

<BR></LI>

<LI>Conditional compilation: #if, #ifdef, #ifndef, #else, #elif, #endif

<BR>

<BR></LI>

<LI>Header files: #include

<BR>

<BR></LI>

<LI>Compile-time error: #error

<BR>

<BR></LI></UL>

<P>The meaning of these directives is familiar to even the novice C programmer.

<BR></P>

<P>The preprocessor also understands (and removes) C and C++ style comments; that is, comments enclosed between /* and */ and comment lines that begin with //.

<BR></P>

<P>The preprocessor also understands the &quot;stringizing&quot; operator # and the &quot;token-pasting&quot; operator ##.

<BR></P>

<P>It is possible to use the same header file from both C source and resource script files. During resource compilation, the resource compiler defines the symbol RC_INVOKED; this symbol can be used in the header file to protect against compiler errors. For example, if the header file contains a class declaration, you may wish to protect it as follows:

<BR></P>

<PRE>#ifndef RC_INVOKED

class myclass

{

...

};

#endif // RC_INVOKED</PRE>

<P>Another useful symbol to remember is the symbol APSTUDIO_INVOKED. This symbol is defined when a resource file is loaded by the integrated resource editor in Developer Studio. (In the days of Visual C++ 1.0, resource editing was performed by a separate program, Application Studio. Hence, the name of this constant.)

<BR></P>

<P>Resource scripts can also contain constant expressions involving the following operators: addition (+), subtraction (-), multiplication (*), division (/), unary not (~), binary and (&amp;), and binary or (|).

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I5" NAME="I5">

<FONT SIZE=3><B>Single-Line Statements</B>

<BR></FONT></A></CENTER></H4>

<P>Single-line statements define bitmaps, cursors, fonts, icons, message tables, and the language of resource statements.

<BR></P>

<P>The BITMAP statement specifies a bitmap file (edited separately with a bitmap editor) that is to define a bitmap resource. For example:

<BR></P>

<PRE>MyBitmap BITMAP mybitmap.bmp</PRE>

<P>The CURSOR statement specifies a file that defines the shape of the mouse cursor. The cursor file is a binary file that is edited by a separate editor. Here is an example for this statement:

<BR></P>

<PRE>MyCursor CURSOR mycursor.cur</PRE>

<P>The FONT statement specifies a font resource. An example:

<BR></P>

<PRE>MyFont FONT myfont.fnt</PRE>

<P>The ICON statement specifies a binary icon file (edited by an icon editor) that defines an icon resource. For example:

<BR></P>

<PRE>MyIcon ICON myicon.ico</PRE>

<P>The LANGUAGE statement sets the language of all subsequent resources up to the end of the resource script or until another LANGUAGE statement is encountered. The LANGUAGE statement can also be used to set the language of a specific resource in a multiline resource statement if it appears just before the BEGIN keyword in such a statement. The LANGUAGE statement is followed by a language and a sublanguage identifier, both of which must be constants defined in the file winnls.h.

<BR></P>

<P>The MESSAGETABLE statement identifies a message table, which is used primarily in Windows NT event logging. A message table is created by the message compiler, mc.exe.

<BR></P>

<P>The BITMAP, CURSOR, FONT, and ICON statements also accept an attribute parameter. The attribute parameter specifies load and memory characteristics of the resource. In 32-bit Windows, only one attribute is used: the DISCARDABLE attribute specifies that a resource can be removed from memory if it is no longer needed. For example:

<BR></P>

<PRE>TempBmp BITMAP DISCARDABLE &quot;c:\\bitmaps\\tempbmp.bmp&quot;</PRE>

<H4 ALIGN="CENTER">

<CENTER><A ID="I6" NAME="I6">

<FONT SIZE=3><B>Multiline Resource Statements</B>

<BR></FONT></A></CENTER></H4>

<P>Multiline resource statements define dialogs, string tables, accelerator tables, menus, and version information resources. Multiline statements begin with an identifier, the statement, and optional parameters, followed by a block of instructions enclosed between a BEGIN-END keyword pair:

<BR></P>

<PRE><I>identifier</I> <I>STATEMENT</I> [<I>optional-parameters</I>]

[<I>optional instructions</I>]

BEGIN

    [<I>instructions</I>]

END</PRE>

<P>Optional instructions may include the CHARACTERISTICS instruction (specifies a single 32-bit value used only by resource file management tools), the LANGUAGE instruction, and the VERSION instruction (specifies a 32-bit version number used by resource management tools). Other optional instructions are multiline statement-specific; for example, the CAPTION instruction defines the title of a dialog box.

<BR></P>

<P>Because of their relative complexity, we'll look at multiline statements individually.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I7" NAME="I7">

<FONT SIZE=3><B>Accelerators</B>

<BR></FONT></A></CENTER></H5>

<P>Accelerators are keystrokes that represent shortcuts to specific tasks. For example, when you use Ctrl+C to copy an item to the clipboard, you are using an accelerator.

<BR></P>

<P>Enclosed between the BEGIN-END keyword pair, an accelerator statement contains an arbitrary number of keyboard events followed by the identifier of the accelerator. Consider the following example:

<BR></P>

<PRE>MyAcc ACCELERATOR

BEGIN

    &quot;C&quot;, ID_EDIT_COPY, VIRTKEY, CONTROL, NOINVERT

    &quot;V&quot;, ID_EDIT_PASTE, VIRTKEY, CONTROL, NOINVERT

    &quot;X&quot;, ID_EDIT_CUT, VIRTKEY, CONTROL, NOINVERT

END</PRE>

<P>This example assumes that the symbolic constants ID_EDIT_COPY, ID_EDIT_PASTE, and ID_EDIT_CUT are defined elsewhere (in a header file) and refer to numeric identifiers.

<BR></P>

<P>Accelerators are interpreted when an application calls the TranslateAccelerator function after retrieving a message through GetMessage (or PeekMessage). TranslateAccelerator translates WM_KEYDOWN (or WM_SYSKEYDOWN) messages into WM_COMMAND (or WM_SYSCOMMAND) messages. The identifiers that follow accelerator keys in an accelerator statement will become the command identifiers in the WM_COMMAND messages.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I8" NAME="I8">

<FONT SIZE=3><B>Dialogs</B>

<BR></FONT></A></CENTER></H5>

<P>Together with menu statements, dialog statements define what are perhaps the most visible parts of a typical application. A dialog statement defines the layout and appearance of a dialog box.

<BR></P>

<P>A sample dialog statement is shown in Listing 10.1. The statement consists of several lines. The first line contains an identifier, the DIALOG keyword, and four numeric parameters that define the position of the dialog's upper-left corner and the size of the dialog box.

<BR></P>

<P>All size and position information in a dialog statement is measured in <I>dialog units</I>. Dialog units are derived from the size of the font specified for the dialog. <I>Dialog base units</I> represent the average height and width of a character in the selected font. Four horizontal dialog units amount to one horizontal dialog base unit; eight vertical dialog units amount to one vertical dialog base unit.

<BR></P>

<P>For dialogs that use the system font, applications can obtain the size of dialog base units, in pixels, by calling GetDialogBaseUnits. For dialogs using other fonts, it may be necessary to explicitly calculate the average size of characters to obtain the dialog base units.

<BR></P>

<P>Once the dialog base units are known, applications can convert between dialog units and pixels using the following formulae:

<BR></P>

<PRE>pixelX = (dialogunitX * baseunitX) / 4

pixelY = (dialogunitY * baseunitY) / 8

dialogunitX = (pixelX * 4) / baseunitX

dialogunitY = (pixelY * 8) / baseunitY</PRE>

<P>Following the line containing the DIALOG keyword, a dialog statement may contain several optional instructions. These may include commonly used optional instructions or dialog-specific optional instructions.

<BR></P>

<P>The CAPTION optional instruction is followed by a string specifying the title of the dialog box. The default is a dialog with no title.

<BR></P>

<P>The STYLE optional instruction specifies the style of the dialog. Style values are usually predefined in the header file windows.h. Several values can be combined using the logical or (|) operator. The default style for dialogs containing no STYLE instruction is WS_POPUP | WS_BORDER | WS_SYSMENU.

<BR></P>

<P>The EXSTYLE optional instruction is similar to STYLE and specifies extended styles.

<BR></P>

<P>The CLASS optional instruction can be used to specify a special window class for a dialog. Using the CLASS instruction should be used sparingly, as it redefines the behavior of the dialog.

<BR></P>

<P>The FONT statement specifies the font to be used in the dialog. The default is the system font.

<BR></P>

<P>The MENU statement identifies the menu resource that defines the menu of the dialog box. In the absence of this statement, the dialog box will be created without a menu bar.

<BR></P>

<P>Enclosed between the BEGIN-END keyword pair is a series of control statements specifying the controls within the dialog. There are several types of control statements. Each control statement contains the control type, control text, a control identifier (text or integer), control position, and control style and extended style parameters:

<BR></P>

<PRE><I>CONTROL-STATEMENT</I> <I>control-text</I>, <I>identifier</I>, <I>x</I>, <I>y</I>, <I>width</I>, <I>height</I> [, <I>style</I> [, <I>extended-style</I>]]</PRE>

<P>An edit control is defined by the EDITTEXT control statement.

<BR></P>

<P>A static control is defined by the LTEXT, CTEXT, RTEXT, or ICON control statement. The first three of these control statements define a left-aligned, centered, or right-aligned static control, respectively. The last specifies a static control with the SS_ICON style.

<BR></P>

<P>A button control is defined by one of the following keywords: AUTO3STATE, AUTOCHECKBOX, AUTORADIOBUTTON, CHECKBOX, DEFPUSHBUTTON, GROUPBOX, PUSHBOX, PUSHBUTTON, RADIOBUTTON, STATE3, USERBUTTON.

<BR></P>

<P>The COMBOBOX control statement defines a combo box control.

<BR></P>

<P>The LISTBOX control statement can be used to specify a list box.

<BR></P>

<P>The SCROLLBAR control statement defines, what else? A scrollbar.

<BR></P>

<P>The CONTROL control statement can be used to define a generic control. The syntax of this statement is somewhat different from the syntax used for other control statements:

<BR></P>

<PRE>CONTROL <I>control-text</I>, <I>identifier</I>, <I>class-name</I>, <I>x</I>, <I>y</I>, <I>width</I>, <I>height</I> [, <I>extended-style</I>]</PRE>

<P>The <I>class-name</I> parameter specifies the window class for the control. This can be one of the Windows control classes. Thus, the CONTROL statement can be used as an alternative syntax for all the other control statements.

<BR></P>

<P>A variant of the DIALOG statement is the DIALOGEX statement. It extends the syntax of the DIALOG statement in the following ways:

<BR></P>

<UL>

<LI>Help identifiers can be specified for the dialog itself as well as any controls within it.

<BR>

<BR></LI>

<LI>Font weight and italic settings can be put in the FONT instruction.

<BR>

<BR></LI>

<LI>Control-specific data can be added to control statements (enclosed by the BEGIN-END keyword pair).

<BR>

<BR></LI>

<LI>The keywords BEDIT, HEDIT, and IEDIT can be used for pen controls.

<BR>

<BR></LI></UL>

<H5 ALIGN="CENTER">

<CENTER><A ID="I9" NAME="I9">

<FONT SIZE=3><B>Menus</B>

<BR></FONT></A></CENTER></H5>

<P>Menu statements in the resource script can be used to specify menu bars or popup menus. Menu statements contain one or more menu definition statements enclosed between a BEGIN-END keyword pair. Consider the following example:

<BR></P>

<PRE>MyMenu MENU

BEGIN

    POPUP &quot;&amp;File&quot;

    BEGIN

        MENUITEM &quot;&amp;New\tCtrl+N&quot;, ID_FILE_NEW

        MENUITEM SEPARATOR

        MENUITEM &quot;E&amp;xit&quot;, ID_FILE_EXIT

    END

    POPUP &quot;&amp;Edit&quot;

    BEGIN

        MENUITEM &quot;Cu&amp;t\tCtrl+X&quot;, ID_EDIT_CUT

        MENUITEM &quot;&amp;Copy\tCtrl+C&quot;, ID_EDIT_COPY

        MENUITEM &quot;&amp;Paste\tCtrl+V&quot;, ID_EDIT_PASTE

    END

    POPUP &quot;&amp;Help&quot;

    BEGIN

        MENUITEM &quot;&amp;About&quot;, ID_HELP_ABOUT

    END

END</PRE>

<P>The identifiers (for example., ID_FILE_NEW) in this example are assumed to be defined elsewhere and refer to numeric values.

<BR></P>

<P>A menu definition statement can specify a menu item or a submenu. To define a menu item, use the MENUITEM keyword. This is followed either by the text of the menu item and the menu identifier or by the SEPARATOR keyword; the latter specifies a separator that is a vertical line for menu bars or a horizontal line for popup (sub) menus.

<BR></P>

<P>A menu item's identifier may be followed by a list of options. Options are separated by commas or spaces and include the following keywords: CHECKED, GRAYED, HELP, INACTIVE, MENUBARBREAK, MENUBREAK.

<BR></P>

<P>To specify a submenu, use the POPUP keyword. The POPUP keyword is followed by the title of the submenu, and a set of menu items enclosed between a BEGIN-END keyword pair. A submenu may contain nested submenus.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I10" NAME="I10">

<FONT SIZE=3><B>String Tables</B>

<BR></FONT></A></CENTER></H5>

<P>A string table resource defines an arbitrary number of text strings. These text strings can be referred to from within the application by symbolic identifiers. The primary advantage of using a string table resource is that it makes it possible for all language-dependent components of an application to be conveniently located within a resource file and thus renders the task of localization substantially easier.

<BR></P>

<P>A string table is defined by the STRINGTABLE keyword, followed by optional instructions, and one or more string definitions enclosed between a BEGIN-END keyword pair. A string definition consists of a string identifier and a string value. For example:

<BR></P>

<PRE>STRINGTABLE

BEGIN

    IDS_HELLO &quot;Hello&quot;

    IDS_GOODBYE &quot;Goodbye&quot;

END</PRE>

<P>where IDS_HELLO and IDS_GOODBYE are symbolic identifiers defined elsewhere.

<BR></P>

<P>Using a string from a string table resource is straightforward. An application can load a string resource using the LoadString function.

<BR></P>

<P>For Microsoft Foundation Class applications, using string table resources is even easier. Many MFC functions that accept a string parameter can also accept a numeric parameter representing a string resource in the application's resource file. For example, an MFC application can display a message box using AfxMessageBox as follows:

<BR></P>

<PRE>AfxMessageBox(IDS_ERROR);</PRE>

<P>Here, IDS_ERROR is a symbolic reference to a numeric identifier.

<BR></P>

<P>The CString class also offers specific support for string resources. The member function CString::LoadString can be used to initialize a CString object to a value obtained from a string table in the application's resource file.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I11" NAME="I11">

<FONT SIZE=3><B>Toolbars</B>

<BR></FONT></A></CENTER></H5>

<P>Toolbar resources are used in MFC applications. A toolbar is defined in a resource file by a TOOLBAR statement. This statement lists the identifiers of the buttons in the toolbar. The size of toolbar buttons is also specified, as in the following example:

<BR></P>

<PRE>IDR_MAINFRAME TOOLBAR DISCARDABLE  16, 15

BEGIN

    BUTTON      ID_FILE_NEW

    BUTTON      ID_FILE_OPEN

    BUTTON      ID_FILE_SAVE

        SEPARATOR

    BUTTON      ID_EDIT_CUT

    BUTTON      ID_EDIT_COPY

    BUTTON      ID_EDIT_PASTE

        SEPARATOR

    BUTTON      ID_FILE_PRINT

    BUTTON      ID_APP_ABOUT

END</PRE>

<P>For every toolbar resource, there should be a corresponding bitmap resource that contains the button bitmaps. The button bitmaps should be arranged horizontally, in the same order as the button identifiers appear in the toolbar resource (except for separators). The bitmap resource should have the same identifier as the toolbar resource:

<BR></P>

<PRE>IDR_MAINFRAME  BITMAP  MOVEABLE PURE   &quot;res\\Toolbar.bmp&quot;</PRE>

<P>Toolbar resources are accessed through the MFC function Ctoolbar::LoadToolBar.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I12" NAME="I12">

<FONT SIZE=3><B>Version Information</B>

<BR></FONT></A></CENTER></H5>

<P>The version information resource can be used to identify the version of a binary file (typically, an executable or library file). Version information is used by File Installation Library functions.

<BR></P>

<P>The version information resource statement contains several version statements that identify the version number of the file and the product, provide additional version information, and specify the language and the target operating system.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I13" NAME="I13">

<FONT SIZE=3><B>User-Defined and Raw Data Resources</B>

<BR></FONT></A></CENTER></H4>

<P>The resource file syntax also allows for the creation of user-defined resource types. A user-defined resource statement can be a single-line or multiline statement. Single-line statements are used to identify user-defined resources that are stored in separate files. The syntax of a single-line statement is as follows:

<BR></P>

<PRE><I>name</I> <I>type</I> [<I>load-memory-options</I>] <I>filename</I></PRE>

<P>Multiline user-defined resource statements can be used to embed the definition of a user-defined resource within the resource file. The syntax of a multiline user-defined resource statement is this:

<BR></P>

<PRE><I>name</I> <I>type</I> [<I>load-memory-options</I>]

BEGIN

    <I>raw-data</I>

END</PRE>

<P>The <I>raw-data</I> block may contain integers in decimal, hexadecimal, or octal notation, or strings enclosed in double quotes. Raw data strings must be explicitly null-terminated. Individual data items are separated by commas.

<BR></P>

<P>Raw data can also be specified in the form of an RCDATA resource. The syntax of an RCDATA statement and the syntax of a multiline user-defined resource statement are nearly identical, except that in the case of raw data statement, the keyword RCDATA is used in place of <I>type</I>, and the statement may also contain the optional instructions CHARACTERISTICS, LANGUAGE, and VERSION.

<BR></P>

<HR ALIGN=CENTER>

<NOTE>

<IMG SRC="note.gif" WIDTH = 35 HEIGHT = 35><B>NOTE:</B> Strings in all resource statements except raw data and user-defined resource statements are interpreted as null-terminated Unicode strings. If you wish to explicitly specify a Unicode string in an RCDATA or user-defined resource statement, use the L prefix.

<BR></NOTE>

<HR ALIGN=CENTER>

<H3 ALIGN="CENTER">

<CENTER><A ID="I14" NAME="I14">

<FONT SIZE=4><B>Compiling and Using Resource Scripts</B>

<BR></FONT></A></CENTER></H3>

<P>Before a resource script can be used by an application, it must be compiled. Although not strictly necessary, in the case of most applications the compiled resource file is also linked with other application components and becomes part of the application's executable file image (.exe file).

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I15" NAME="I15">

<FONT SIZE=3><B>Running the Resource Compiler</B>

<BR></FONT></A></CENTER></H4>

<P>A resource file can be compiled from the command line using the resource compiler, rc.exe. For most resource files, this command can be used with no parameters. For example, to compile the resource file shown in Listing 10.1, you would type rc dlg.rc.

<BR></P>

<P>In 16-bit versions of Windows, the resource compiler was also used to add resources to the executable file. In Win32, the 32-bit linker is used for this purpose.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I16" NAME="I16">

<FONT SIZE=3><B>Running the Linker</B>

<BR></FONT></A></CENTER></H4>

<P>The Visual C++ linker, link.exe, can be used to link a resource file and other components of an application's executable together. In the simplest case, you would specify the name of the compiled resource file on the C/C++ compiler command line just as you would specify any other object file or library file. For example:

<BR></P>

<PRE>cl dlg.cpp dlg.res user32.lib</PRE>

<P>In order for the linker to work properly with compiled resource files, the cvtres.exe tool must be present in the same directory as the linker executable, link.exe. This tool converts compiled resource files into the Common Object File Format (COFF) which is understood by the linker.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I17" NAME="I17">

<FONT SIZE=3><B>Resource DLLs</B>

<BR></FONT></A></CENTER></H4>

<P>Resources do not need to be linked with your application's executable file. They can also be linked into a separate dynamic-link library. This has the advantage that changing the application's resource file does not require recompiling the entire application, only replacing the DLL. You can also ship your application with multiple DLLs representing resources in various languages. In MFC applications, this approach is made even easier by the AfxSetResourceHandle call; calling this function with a handle to a resource DLL ensures that subsequently, the MFC loads all resources from that DLL instead of your application's executable file.

<BR></P>

<H3 ALIGN="CENTER">

<CENTER><A ID="I18" NAME="I18">

<FONT SIZE=4><B>Summary</B>

<BR></FONT></A></CENTER></H3>

<P>Resource files define the visual appearance of an application. Resources include dialogs, menus, bitmaps, icons, cursors, text strings, and several other types.

<BR></P>

<P>While resources are typically created with graphical editors, it is possible (and sometimes necessary) to edit the resource file directly. Resource files (files with the .rc extension) are human readable ASCII text files.

<BR></P>

<P>Resource files contain preprocessor directives, single-line, and multiline resource statements. Preprocessor directives are similar in syntax and semantics to their C/C++ counterparts. Single-line resource file statements are used to identify resources stored in separate binary files (edited by specialized editors): bitmaps, icons, cursors, fonts, and generic resources. Single-line statements are also used to specify message table resources (used for Windows NT event logging) and to specify the language of subsequent resource statements.

<BR></P>

<P>Multiline statements are used to define menus, dialogs, string tables, accelerator tables, version information resources, and generic resources.

<BR></P>

<P>Resource files are compiled using the Resource Compiler, rc.exe. The resulting compiled resource file (usually a file with the .res extension) is suitable for linking with other components of the application. A compiled resource file can also be specified on the cl command line.</P>

<P><A HREF="vcu09fi.htm"><IMG SRC="bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="index.htm"><IMG SRC="blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="vcu11fi.htm"><IMG SRC="blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>

</P></BODY></HTML>

